// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "storage.pb.h"
#include "stats.pb.h"
// @@protoc_insertion_point(includes)

namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class LoginRequest;
class LoginResponse;
class Add;
class AddReplay;
class UserBasicInformation;
class UserData;
class UserActivityStatistics;

enum Replay {
  LOGIN_OK = 1,
  BAD_USER_OR_PASSWD = 10,
  USER_ALREADY_LOGGED_IN = 11
};
bool Replay_IsValid(int value);
const Replay Replay_MIN = LOGIN_OK;
const Replay Replay_MAX = USER_ALREADY_LOGGED_IN;
const int Replay_ARRAYSIZE = Replay_MAX + 1;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:user.LoginRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string* name_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 14];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required .user.Replay replay = 2;
  inline bool has_replay() const;
  inline void clear_replay();
  static const int kReplayFieldNumber = 2;
  inline ::user::Replay replay() const;
  inline void set_replay(::user::Replay value);

  // @@protoc_insertion_point(class_scope:user.LoginResponse)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_replay();
  inline void clear_has_replay();

  ::google::protobuf::uint32 msgtype_;
  int replay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Add : public ::google::protobuf::MessageLite {
 public:
  Add();
  virtual ~Add();

  Add(const Add& from);

  inline Add& operator=(const Add& from) {
    CopyFrom(from);
    return *this;
  }

  static const Add& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Add* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Add* other);

  // implements Message ----------------------------------------------

  Add* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Add& from);
  void MergeFrom(const Add& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phonenumber = 8;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 8;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const void* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // @@protoc_insertion_point(class_scope:user.Add)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();

  ::std::string* name_;
  ::std::string* password_;
  ::std::string* email_;
  ::std::string* address_;
  ::std::string* phonenumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static Add* default_instance_;
};
// -------------------------------------------------------------------

class AddReplay : public ::google::protobuf::MessageLite {
 public:
  AddReplay();
  virtual ~AddReplay();

  AddReplay(const AddReplay& from);

  inline AddReplay& operator=(const AddReplay& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddReplay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddReplay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddReplay* other);

  // implements Message ----------------------------------------------

  AddReplay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddReplay& from);
  void MergeFrom(const AddReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .QueryStats stats = 2;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::QueryStats& stats() const;
  inline ::QueryStats* mutable_stats();
  inline ::QueryStats* release_stats();
  inline void set_allocated_stats(::QueryStats* stats);

  // required .user.Replay replay = 3;
  inline bool has_replay() const;
  inline void clear_replay();
  static const int kReplayFieldNumber = 3;
  inline ::user::Replay replay() const;
  inline void set_replay(::user::Replay value);

  // @@protoc_insertion_point(class_scope:user.AddReplay)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_replay();
  inline void clear_has_replay();

  ::QueryStats* stats_;
  int replay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static AddReplay* default_instance_;
};
// -------------------------------------------------------------------

class UserBasicInformation : public ::google::protobuf::MessageLite {
 public:
  UserBasicInformation();
  virtual ~UserBasicInformation();

  UserBasicInformation(const UserBasicInformation& from);

  inline UserBasicInformation& operator=(const UserBasicInformation& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserBasicInformation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserBasicInformation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserBasicInformation* other);

  // implements Message ----------------------------------------------

  UserBasicInformation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserBasicInformation& from);
  void MergeFrom(const UserBasicInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:user.UserBasicInformation)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();

  ::std::string* name_;
  ::std::string* email_;
  ::std::string* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserBasicInformation* default_instance_;
};
// -------------------------------------------------------------------

class UserData : public ::google::protobuf::MessageLite {
 public:
  UserData();
  virtual ~UserData();

  UserData(const UserData& from);

  inline UserData& operator=(const UserData& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserData* other);

  // implements Message ----------------------------------------------

  UserData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserData& from);
  void MergeFrom(const UserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // repeated .storage.Storage storages = 11;
  inline int storages_size() const;
  inline void clear_storages();
  static const int kStoragesFieldNumber = 11;
  inline const ::storage::Storage& storages(int index) const;
  inline ::storage::Storage* mutable_storages(int index);
  inline ::storage::Storage* add_storages();
  inline const ::google::protobuf::RepeatedPtrField< ::storage::Storage >&
      storages() const;
  inline ::google::protobuf::RepeatedPtrField< ::storage::Storage >*
      mutable_storages();

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phoneNumber = 6;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhoneNumberFieldNumber = 6;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const void* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional uint64 lastLogin = 7;
  inline bool has_lastlogin() const;
  inline void clear_lastlogin();
  static const int kLastLoginFieldNumber = 7;
  inline ::google::protobuf::uint64 lastlogin() const;
  inline void set_lastlogin(::google::protobuf::uint64 value);

  // optional uint64 registrationdate = 8;
  inline bool has_registrationdate() const;
  inline void clear_registrationdate();
  static const int kRegistrationdateFieldNumber = 8;
  inline ::google::protobuf::uint64 registrationdate() const;
  inline void set_registrationdate(::google::protobuf::uint64 value);

  // optional bytes config = 9;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 9;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const void* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional .user.UserActivityStatistics stats = 10;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 10;
  inline const ::user::UserActivityStatistics& stats() const;
  inline ::user::UserActivityStatistics* mutable_stats();
  inline ::user::UserActivityStatistics* release_stats();
  inline void set_allocated_stats(::user::UserActivityStatistics* stats);

  // optional bytes description = 12;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 12;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:user.UserData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_lastlogin();
  inline void clear_has_lastlogin();
  inline void set_has_registrationdate();
  inline void clear_has_registrationdate();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_description();
  inline void clear_has_description();

  ::std::string* name_;
  ::std::string* email_;
  ::google::protobuf::RepeatedPtrField< ::storage::Storage > storages_;
  ::std::string* address_;
  ::std::string* phonenumber_;
  ::google::protobuf::uint64 lastlogin_;
  ::google::protobuf::uint64 registrationdate_;
  ::std::string* config_;
  ::user::UserActivityStatistics* stats_;
  ::std::string* description_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserData* default_instance_;
};
// -------------------------------------------------------------------

class UserActivityStatistics : public ::google::protobuf::MessageLite {
 public:
  UserActivityStatistics();
  virtual ~UserActivityStatistics();

  UserActivityStatistics(const UserActivityStatistics& from);

  inline UserActivityStatistics& operator=(const UserActivityStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserActivityStatistics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserActivityStatistics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserActivityStatistics* other);

  // implements Message ----------------------------------------------

  UserActivityStatistics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserActivityStatistics& from);
  void MergeFrom(const UserActivityStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 magazineCount = 1;
  inline bool has_magazinecount() const;
  inline void clear_magazinecount();
  static const int kMagazineCountFieldNumber = 1;
  inline ::google::protobuf::uint32 magazinecount() const;
  inline void set_magazinecount(::google::protobuf::uint32 value);

  // required uint32 totalNumOfElements = 2;
  inline bool has_totalnumofelements() const;
  inline void clear_totalnumofelements();
  static const int kTotalNumOfElementsFieldNumber = 2;
  inline ::google::protobuf::uint32 totalnumofelements() const;
  inline void set_totalnumofelements(::google::protobuf::uint32 value);

  // required uint32 totalNumOfUniqueElements = 3;
  inline bool has_totalnumofuniqueelements() const;
  inline void clear_totalnumofuniqueelements();
  static const int kTotalNumOfUniqueElementsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalnumofuniqueelements() const;
  inline void set_totalnumofuniqueelements(::google::protobuf::uint32 value);

  // required uint32 totalNumOfRequests = 5;
  inline bool has_totalnumofrequests() const;
  inline void clear_totalnumofrequests();
  static const int kTotalNumOfRequestsFieldNumber = 5;
  inline ::google::protobuf::uint32 totalnumofrequests() const;
  inline void set_totalnumofrequests(::google::protobuf::uint32 value);

  // required uint32 totalModifiedItems = 6;
  inline bool has_totalmodifieditems() const;
  inline void clear_totalmodifieditems();
  static const int kTotalModifiedItemsFieldNumber = 6;
  inline ::google::protobuf::uint32 totalmodifieditems() const;
  inline void set_totalmodifieditems(::google::protobuf::uint32 value);

  // required uint32 totalAddItems = 7;
  inline bool has_totaladditems() const;
  inline void clear_totaladditems();
  static const int kTotalAddItemsFieldNumber = 7;
  inline ::google::protobuf::uint32 totaladditems() const;
  inline void set_totaladditems(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:user.UserActivityStatistics)
 private:
  inline void set_has_magazinecount();
  inline void clear_has_magazinecount();
  inline void set_has_totalnumofelements();
  inline void clear_has_totalnumofelements();
  inline void set_has_totalnumofuniqueelements();
  inline void clear_has_totalnumofuniqueelements();
  inline void set_has_totalnumofrequests();
  inline void clear_has_totalnumofrequests();
  inline void set_has_totalmodifieditems();
  inline void clear_has_totalmodifieditems();
  inline void set_has_totaladditems();
  inline void clear_has_totaladditems();

  ::google::protobuf::uint32 magazinecount_;
  ::google::protobuf::uint32 totalnumofelements_;
  ::google::protobuf::uint32 totalnumofuniqueelements_;
  ::google::protobuf::uint32 totalnumofrequests_;
  ::google::protobuf::uint32 totalmodifieditems_;
  ::google::protobuf::uint32 totaladditems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserActivityStatistics* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string name = 3;
inline bool LoginRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginRequest::name() const {
  return *name_;
}
inline void LoginRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required uint32 msgType = 1 [default = 14];
inline bool LoginResponse::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_msgtype() {
  msgtype_ = 14u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 LoginResponse::msgtype() const {
  return msgtype_;
}
inline void LoginResponse::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required .user.Replay replay = 2;
inline bool LoginResponse::has_replay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_replay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_replay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_replay() {
  replay_ = 1;
  clear_has_replay();
}
inline ::user::Replay LoginResponse::replay() const {
  return static_cast< ::user::Replay >(replay_);
}
inline void LoginResponse::set_replay(::user::Replay value) {
  assert(::user::Replay_IsValid(value));
  set_has_replay();
  replay_ = value;
}

// -------------------------------------------------------------------

// Add

// required string name = 2;
inline bool Add::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Add::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Add::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Add::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Add::name() const {
  return *name_;
}
inline void Add::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Add::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Add::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Add::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool Add::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Add::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Add::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Add::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Add::password() const {
  return *password_;
}
inline void Add::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Add::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Add::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Add::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 4;
inline bool Add::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Add::set_has_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Add::clear_has_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Add::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Add::email() const {
  return *email_;
}
inline void Add::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Add::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Add::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* Add::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool Add::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Add::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Add::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Add::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Add::address() const {
  return *address_;
}
inline void Add::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Add::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Add::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Add::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes phonenumber = 8;
inline bool Add::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Add::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Add::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Add::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& Add::phonenumber() const {
  return *phonenumber_;
}
inline void Add::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Add::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Add::set_phonenumber(const void* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* Add::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddReplay

// required .QueryStats stats = 2;
inline bool AddReplay::has_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddReplay::set_has_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddReplay::clear_has_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddReplay::clear_stats() {
  if (stats_ != NULL) stats_->::QueryStats::Clear();
  clear_has_stats();
}
inline const ::QueryStats& AddReplay::stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_ != NULL ? *stats_ : *default_instance().stats_;
#else
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
#endif
}
inline ::QueryStats* AddReplay::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::QueryStats;
  return stats_;
}
inline ::QueryStats* AddReplay::release_stats() {
  clear_has_stats();
  ::QueryStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void AddReplay::set_allocated_stats(::QueryStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// required .user.Replay replay = 3;
inline bool AddReplay::has_replay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddReplay::set_has_replay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddReplay::clear_has_replay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddReplay::clear_replay() {
  replay_ = 1;
  clear_has_replay();
}
inline ::user::Replay AddReplay::replay() const {
  return static_cast< ::user::Replay >(replay_);
}
inline void AddReplay::set_replay(::user::Replay value) {
  assert(::user::Replay_IsValid(value));
  set_has_replay();
  replay_ = value;
}

// -------------------------------------------------------------------

// UserBasicInformation

// required string name = 3;
inline bool UserBasicInformation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBasicInformation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBasicInformation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBasicInformation::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserBasicInformation::name() const {
  return *name_;
}
inline void UserBasicInformation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBasicInformation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBasicInformation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBasicInformation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserBasicInformation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBasicInformation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool UserBasicInformation::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBasicInformation::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBasicInformation::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBasicInformation::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserBasicInformation::email() const {
  return *email_;
}
inline void UserBasicInformation::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserBasicInformation::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserBasicInformation::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBasicInformation::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserBasicInformation::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBasicInformation::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool UserBasicInformation::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBasicInformation::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBasicInformation::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBasicInformation::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserBasicInformation::address() const {
  return *address_;
}
inline void UserBasicInformation::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserBasicInformation::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserBasicInformation::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBasicInformation::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserBasicInformation::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBasicInformation::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserData

// required uint32 ID = 2;
inline bool UserData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UserData::id() const {
  return id_;
}
inline void UserData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 3;
inline bool UserData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserData::name() const {
  return *name_;
}
inline void UserData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 4;
inline bool UserData::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserData::set_has_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserData::clear_has_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserData::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserData::email() const {
  return *email_;
}
inline void UserData::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserData::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserData::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserData::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .storage.Storage storages = 11;
inline int UserData::storages_size() const {
  return storages_.size();
}
inline void UserData::clear_storages() {
  storages_.Clear();
}
inline const ::storage::Storage& UserData::storages(int index) const {
  return storages_.Get(index);
}
inline ::storage::Storage* UserData::mutable_storages(int index) {
  return storages_.Mutable(index);
}
inline ::storage::Storage* UserData::add_storages() {
  return storages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::storage::Storage >&
UserData::storages() const {
  return storages_;
}
inline ::google::protobuf::RepeatedPtrField< ::storage::Storage >*
UserData::mutable_storages() {
  return &storages_;
}

// optional string address = 5;
inline bool UserData::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserData::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserData::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserData::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserData::address() const {
  return *address_;
}
inline void UserData::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserData::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserData::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserData::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes phoneNumber = 6;
inline bool UserData::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserData::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserData::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserData::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& UserData::phonenumber() const {
  return *phonenumber_;
}
inline void UserData::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void UserData::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void UserData::set_phonenumber(const void* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* UserData::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 lastLogin = 7;
inline bool UserData::has_lastlogin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserData::set_has_lastlogin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserData::clear_has_lastlogin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserData::clear_lastlogin() {
  lastlogin_ = GOOGLE_ULONGLONG(0);
  clear_has_lastlogin();
}
inline ::google::protobuf::uint64 UserData::lastlogin() const {
  return lastlogin_;
}
inline void UserData::set_lastlogin(::google::protobuf::uint64 value) {
  set_has_lastlogin();
  lastlogin_ = value;
}

// optional uint64 registrationdate = 8;
inline bool UserData::has_registrationdate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserData::set_has_registrationdate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserData::clear_has_registrationdate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserData::clear_registrationdate() {
  registrationdate_ = GOOGLE_ULONGLONG(0);
  clear_has_registrationdate();
}
inline ::google::protobuf::uint64 UserData::registrationdate() const {
  return registrationdate_;
}
inline void UserData::set_registrationdate(::google::protobuf::uint64 value) {
  set_has_registrationdate();
  registrationdate_ = value;
}

// optional bytes config = 9;
inline bool UserData::has_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserData::set_has_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserData::clear_has_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserData::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& UserData::config() const {
  return *config_;
}
inline void UserData::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void UserData::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void UserData::set_config(const void* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* UserData::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .user.UserActivityStatistics stats = 10;
inline bool UserData::has_stats() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserData::set_has_stats() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserData::clear_has_stats() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserData::clear_stats() {
  if (stats_ != NULL) stats_->::user::UserActivityStatistics::Clear();
  clear_has_stats();
}
inline const ::user::UserActivityStatistics& UserData::stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_ != NULL ? *stats_ : *default_instance().stats_;
#else
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
#endif
}
inline ::user::UserActivityStatistics* UserData::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::user::UserActivityStatistics;
  return stats_;
}
inline ::user::UserActivityStatistics* UserData::release_stats() {
  clear_has_stats();
  ::user::UserActivityStatistics* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void UserData::set_allocated_stats(::user::UserActivityStatistics* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// optional bytes description = 12;
inline bool UserData::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserData::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserData::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserData::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& UserData::description() const {
  return *description_;
}
inline void UserData::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UserData::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void UserData::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* UserData::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserActivityStatistics

// required uint32 magazineCount = 1;
inline bool UserActivityStatistics::has_magazinecount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActivityStatistics::set_has_magazinecount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActivityStatistics::clear_has_magazinecount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActivityStatistics::clear_magazinecount() {
  magazinecount_ = 0u;
  clear_has_magazinecount();
}
inline ::google::protobuf::uint32 UserActivityStatistics::magazinecount() const {
  return magazinecount_;
}
inline void UserActivityStatistics::set_magazinecount(::google::protobuf::uint32 value) {
  set_has_magazinecount();
  magazinecount_ = value;
}

// required uint32 totalNumOfElements = 2;
inline bool UserActivityStatistics::has_totalnumofelements() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofelements() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserActivityStatistics::clear_has_totalnumofelements() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserActivityStatistics::clear_totalnumofelements() {
  totalnumofelements_ = 0u;
  clear_has_totalnumofelements();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofelements() const {
  return totalnumofelements_;
}
inline void UserActivityStatistics::set_totalnumofelements(::google::protobuf::uint32 value) {
  set_has_totalnumofelements();
  totalnumofelements_ = value;
}

// required uint32 totalNumOfUniqueElements = 3;
inline bool UserActivityStatistics::has_totalnumofuniqueelements() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofuniqueelements() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserActivityStatistics::clear_has_totalnumofuniqueelements() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserActivityStatistics::clear_totalnumofuniqueelements() {
  totalnumofuniqueelements_ = 0u;
  clear_has_totalnumofuniqueelements();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofuniqueelements() const {
  return totalnumofuniqueelements_;
}
inline void UserActivityStatistics::set_totalnumofuniqueelements(::google::protobuf::uint32 value) {
  set_has_totalnumofuniqueelements();
  totalnumofuniqueelements_ = value;
}

// required uint32 totalNumOfRequests = 5;
inline bool UserActivityStatistics::has_totalnumofrequests() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofrequests() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserActivityStatistics::clear_has_totalnumofrequests() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserActivityStatistics::clear_totalnumofrequests() {
  totalnumofrequests_ = 0u;
  clear_has_totalnumofrequests();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofrequests() const {
  return totalnumofrequests_;
}
inline void UserActivityStatistics::set_totalnumofrequests(::google::protobuf::uint32 value) {
  set_has_totalnumofrequests();
  totalnumofrequests_ = value;
}

// required uint32 totalModifiedItems = 6;
inline bool UserActivityStatistics::has_totalmodifieditems() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserActivityStatistics::set_has_totalmodifieditems() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserActivityStatistics::clear_has_totalmodifieditems() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserActivityStatistics::clear_totalmodifieditems() {
  totalmodifieditems_ = 0u;
  clear_has_totalmodifieditems();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalmodifieditems() const {
  return totalmodifieditems_;
}
inline void UserActivityStatistics::set_totalmodifieditems(::google::protobuf::uint32 value) {
  set_has_totalmodifieditems();
  totalmodifieditems_ = value;
}

// required uint32 totalAddItems = 7;
inline bool UserActivityStatistics::has_totaladditems() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserActivityStatistics::set_has_totaladditems() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserActivityStatistics::clear_has_totaladditems() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserActivityStatistics::clear_totaladditems() {
  totaladditems_ = 0u;
  clear_has_totaladditems();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totaladditems() const {
  return totaladditems_;
}
inline void UserActivityStatistics::set_totaladditems(::google::protobuf::uint32 value) {
  set_has_totaladditems();
  totaladditems_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
