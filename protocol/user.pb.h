// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "stats.pb.h"
// @@protoc_insertion_point(includes)

namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class LoginRequest;
class LogoutRequest;
class LoginResponse;
class Add;
class AddReplay;
class UserData;
class UserActivityStatistics;

enum Replay {
  LOGIN_OK = 1,
  BAD_USER_OR_PASSWD = 10,
  USER_ALREADY_LOGGED_IN = 11
};
bool Replay_IsValid(int value);
const Replay Replay_MIN = LOGIN_OK;
const Replay Replay_MAX = USER_ALREADY_LOGGED_IN;
const int Replay_ARRAYSIZE = Replay_MAX + 1;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 1];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:user.LoginRequest)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string* name_;
  ::std::string* password_;
  ::google::protobuf::uint32 msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::MessageLite {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LogoutRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LogoutRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LogoutRequest* other);

  // implements Message ----------------------------------------------

  LogoutRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 2];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:user.LogoutRequest)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();

  ::google::protobuf::uint32 msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 14];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required .user.Replay replay = 2;
  inline bool has_replay() const;
  inline void clear_replay();
  static const int kReplayFieldNumber = 2;
  inline ::user::Replay replay() const;
  inline void set_replay(::user::Replay value);

  // @@protoc_insertion_point(class_scope:user.LoginResponse)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_replay();
  inline void clear_has_replay();

  ::google::protobuf::uint32 msgtype_;
  int replay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Add : public ::google::protobuf::MessageLite {
 public:
  Add();
  virtual ~Add();

  Add(const Add& from);

  inline Add& operator=(const Add& from) {
    CopyFrom(from);
    return *this;
  }

  static const Add& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Add* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Add* other);

  // implements Message ----------------------------------------------

  Add* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Add& from);
  void MergeFrom(const Add& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 3];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phonenumber = 8;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 8;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const void* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // @@protoc_insertion_point(class_scope:user.Add)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();

  ::std::string* name_;
  ::std::string* password_;
  ::std::string* email_;
  ::std::string* address_;
  ::std::string* phonenumber_;
  ::google::protobuf::uint32 msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static Add* default_instance_;
};
// -------------------------------------------------------------------

class AddReplay : public ::google::protobuf::MessageLite {
 public:
  AddReplay();
  virtual ~AddReplay();

  AddReplay(const AddReplay& from);

  inline AddReplay& operator=(const AddReplay& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddReplay& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddReplay* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddReplay* other);

  // implements Message ----------------------------------------------

  AddReplay* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddReplay& from);
  void MergeFrom(const AddReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 4];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required .QueryStats stats = 2;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::QueryStats& stats() const;
  inline ::QueryStats* mutable_stats();
  inline ::QueryStats* release_stats();
  inline void set_allocated_stats(::QueryStats* stats);

  // required .user.Replay replay = 3;
  inline bool has_replay() const;
  inline void clear_replay();
  static const int kReplayFieldNumber = 3;
  inline ::user::Replay replay() const;
  inline void set_replay(::user::Replay value);

  // @@protoc_insertion_point(class_scope:user.AddReplay)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_replay();
  inline void clear_has_replay();

  ::QueryStats* stats_;
  ::google::protobuf::uint32 msgtype_;
  int replay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static AddReplay* default_instance_;
};
// -------------------------------------------------------------------

class UserData : public ::google::protobuf::MessageLite {
 public:
  UserData();
  virtual ~UserData();

  UserData(const UserData& from);

  inline UserData& operator=(const UserData& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserData* other);

  // implements Message ----------------------------------------------

  UserData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserData& from);
  void MergeFrom(const UserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgType = 1 [default = 5];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // required uint32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes phoneNumber = 6;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhoneNumberFieldNumber = 6;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const void* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // optional uint64 lastLogin = 7;
  inline bool has_lastlogin() const;
  inline void clear_lastlogin();
  static const int kLastLoginFieldNumber = 7;
  inline ::google::protobuf::uint64 lastlogin() const;
  inline void set_lastlogin(::google::protobuf::uint64 value);

  // optional uint64 firstLogin = 8;
  inline bool has_firstlogin() const;
  inline void clear_firstlogin();
  static const int kFirstLoginFieldNumber = 8;
  inline ::google::protobuf::uint64 firstlogin() const;
  inline void set_firstlogin(::google::protobuf::uint64 value);

  // optional .user.UserActivityStatistics stats = 10;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 10;
  inline const ::user::UserActivityStatistics& stats() const;
  inline ::user::UserActivityStatistics* mutable_stats();
  inline ::user::UserActivityStatistics* release_stats();
  inline void set_allocated_stats(::user::UserActivityStatistics* stats);

  // @@protoc_insertion_point(class_scope:user.UserData)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();
  inline void set_has_lastlogin();
  inline void clear_has_lastlogin();
  inline void set_has_firstlogin();
  inline void clear_has_firstlogin();
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::uint32 msgtype_;
  ::google::protobuf::uint32 id_;
  ::std::string* name_;
  ::std::string* email_;
  ::std::string* address_;
  ::std::string* phonenumber_;
  ::google::protobuf::uint64 lastlogin_;
  ::google::protobuf::uint64 firstlogin_;
  ::user::UserActivityStatistics* stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserData* default_instance_;
};
// -------------------------------------------------------------------

class UserActivityStatistics : public ::google::protobuf::MessageLite {
 public:
  UserActivityStatistics();
  virtual ~UserActivityStatistics();

  UserActivityStatistics(const UserActivityStatistics& from);

  inline UserActivityStatistics& operator=(const UserActivityStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserActivityStatistics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserActivityStatistics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserActivityStatistics* other);

  // implements Message ----------------------------------------------

  UserActivityStatistics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserActivityStatistics& from);
  void MergeFrom(const UserActivityStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 magazineCount = 1;
  inline bool has_magazinecount() const;
  inline void clear_magazinecount();
  static const int kMagazineCountFieldNumber = 1;
  inline ::google::protobuf::uint32 magazinecount() const;
  inline void set_magazinecount(::google::protobuf::uint32 value);

  // required uint32 totalNumOfElements = 2;
  inline bool has_totalnumofelements() const;
  inline void clear_totalnumofelements();
  static const int kTotalNumOfElementsFieldNumber = 2;
  inline ::google::protobuf::uint32 totalnumofelements() const;
  inline void set_totalnumofelements(::google::protobuf::uint32 value);

  // required uint32 totalNumOfGroupedElements = 3;
  inline bool has_totalnumofgroupedelements() const;
  inline void clear_totalnumofgroupedelements();
  static const int kTotalNumOfGroupedElementsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalnumofgroupedelements() const;
  inline void set_totalnumofgroupedelements(::google::protobuf::uint32 value);

  // required uint32 totalNumOfExecutedQueries = 4;
  inline bool has_totalnumofexecutedqueries() const;
  inline void clear_totalnumofexecutedqueries();
  static const int kTotalNumOfExecutedQueriesFieldNumber = 4;
  inline ::google::protobuf::uint32 totalnumofexecutedqueries() const;
  inline void set_totalnumofexecutedqueries(::google::protobuf::uint32 value);

  // required uint32 totalNumOfRequests = 5;
  inline bool has_totalnumofrequests() const;
  inline void clear_totalnumofrequests();
  static const int kTotalNumOfRequestsFieldNumber = 5;
  inline ::google::protobuf::uint32 totalnumofrequests() const;
  inline void set_totalnumofrequests(::google::protobuf::uint32 value);

  // required uint32 totalModifiedItems = 6;
  inline bool has_totalmodifieditems() const;
  inline void clear_totalmodifieditems();
  static const int kTotalModifiedItemsFieldNumber = 6;
  inline ::google::protobuf::uint32 totalmodifieditems() const;
  inline void set_totalmodifieditems(::google::protobuf::uint32 value);

  // required uint32 totalAddItems = 7;
  inline bool has_totaladditems() const;
  inline void clear_totaladditems();
  static const int kTotalAddItemsFieldNumber = 7;
  inline ::google::protobuf::uint32 totaladditems() const;
  inline void set_totaladditems(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:user.UserActivityStatistics)
 private:
  inline void set_has_magazinecount();
  inline void clear_has_magazinecount();
  inline void set_has_totalnumofelements();
  inline void clear_has_totalnumofelements();
  inline void set_has_totalnumofgroupedelements();
  inline void clear_has_totalnumofgroupedelements();
  inline void set_has_totalnumofexecutedqueries();
  inline void clear_has_totalnumofexecutedqueries();
  inline void set_has_totalnumofrequests();
  inline void clear_has_totalnumofrequests();
  inline void set_has_totalmodifieditems();
  inline void clear_has_totalmodifieditems();
  inline void set_has_totaladditems();
  inline void clear_has_totaladditems();

  ::google::protobuf::uint32 magazinecount_;
  ::google::protobuf::uint32 totalnumofelements_;
  ::google::protobuf::uint32 totalnumofgroupedelements_;
  ::google::protobuf::uint32 totalnumofexecutedqueries_;
  ::google::protobuf::uint32 totalnumofrequests_;
  ::google::protobuf::uint32 totalmodifieditems_;
  ::google::protobuf::uint32 totaladditems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserActivityStatistics* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required uint32 msgType = 1 [default = 1];
inline bool LoginRequest::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_msgtype() {
  msgtype_ = 1u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 LoginRequest::msgtype() const {
  return msgtype_;
}
inline void LoginRequest::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string name = 3;
inline bool LoginRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginRequest::name() const {
  return *name_;
}
inline void LoginRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogoutRequest

// required uint32 msgType = 1 [default = 2];
inline bool LogoutRequest::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequest::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRequest::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRequest::clear_msgtype() {
  msgtype_ = 2u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 LogoutRequest::msgtype() const {
  return msgtype_;
}
inline void LogoutRequest::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// -------------------------------------------------------------------

// LoginResponse

// required uint32 msgType = 1 [default = 14];
inline bool LoginResponse::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_msgtype() {
  msgtype_ = 14u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 LoginResponse::msgtype() const {
  return msgtype_;
}
inline void LoginResponse::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required .user.Replay replay = 2;
inline bool LoginResponse::has_replay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_replay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_replay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_replay() {
  replay_ = 1;
  clear_has_replay();
}
inline ::user::Replay LoginResponse::replay() const {
  return static_cast< ::user::Replay >(replay_);
}
inline void LoginResponse::set_replay(::user::Replay value) {
  assert(::user::Replay_IsValid(value));
  set_has_replay();
  replay_ = value;
}

// -------------------------------------------------------------------

// Add

// required uint32 msgType = 1 [default = 3];
inline bool Add::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Add::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Add::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Add::clear_msgtype() {
  msgtype_ = 3u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 Add::msgtype() const {
  return msgtype_;
}
inline void Add::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string name = 2;
inline bool Add::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Add::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Add::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Add::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Add::name() const {
  return *name_;
}
inline void Add::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Add::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Add::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Add::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool Add::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Add::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Add::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Add::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Add::password() const {
  return *password_;
}
inline void Add::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Add::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Add::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Add::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 4;
inline bool Add::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Add::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Add::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Add::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Add::email() const {
  return *email_;
}
inline void Add::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Add::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void Add::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* Add::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool Add::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Add::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Add::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Add::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Add::address() const {
  return *address_;
}
inline void Add::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Add::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Add::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Add::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes phonenumber = 8;
inline bool Add::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Add::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Add::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Add::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& Add::phonenumber() const {
  return *phonenumber_;
}
inline void Add::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Add::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Add::set_phonenumber(const void* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Add::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* Add::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Add::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddReplay

// required uint32 msgType = 1 [default = 4];
inline bool AddReplay::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddReplay::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddReplay::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddReplay::clear_msgtype() {
  msgtype_ = 4u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 AddReplay::msgtype() const {
  return msgtype_;
}
inline void AddReplay::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required .QueryStats stats = 2;
inline bool AddReplay::has_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddReplay::set_has_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddReplay::clear_has_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddReplay::clear_stats() {
  if (stats_ != NULL) stats_->::QueryStats::Clear();
  clear_has_stats();
}
inline const ::QueryStats& AddReplay::stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_ != NULL ? *stats_ : *default_instance().stats_;
#else
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
#endif
}
inline ::QueryStats* AddReplay::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::QueryStats;
  return stats_;
}
inline ::QueryStats* AddReplay::release_stats() {
  clear_has_stats();
  ::QueryStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void AddReplay::set_allocated_stats(::QueryStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// required .user.Replay replay = 3;
inline bool AddReplay::has_replay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddReplay::set_has_replay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddReplay::clear_has_replay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddReplay::clear_replay() {
  replay_ = 1;
  clear_has_replay();
}
inline ::user::Replay AddReplay::replay() const {
  return static_cast< ::user::Replay >(replay_);
}
inline void AddReplay::set_replay(::user::Replay value) {
  assert(::user::Replay_IsValid(value));
  set_has_replay();
  replay_ = value;
}

// -------------------------------------------------------------------

// UserData

// required uint32 msgType = 1 [default = 5];
inline bool UserData::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserData::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserData::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserData::clear_msgtype() {
  msgtype_ = 5u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 UserData::msgtype() const {
  return msgtype_;
}
inline void UserData::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required uint32 ID = 2;
inline bool UserData::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserData::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserData::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UserData::id() const {
  return id_;
}
inline void UserData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 3;
inline bool UserData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserData::name() const {
  return *name_;
}
inline void UserData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 4;
inline bool UserData::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserData::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserData::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserData::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserData::email() const {
  return *email_;
}
inline void UserData::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserData::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserData::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserData::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool UserData::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserData::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserData::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserData::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserData::address() const {
  return *address_;
}
inline void UserData::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserData::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserData::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserData::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes phoneNumber = 6;
inline bool UserData::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserData::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserData::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserData::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& UserData::phonenumber() const {
  return *phonenumber_;
}
inline void UserData::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void UserData::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void UserData::set_phonenumber(const void* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserData::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* UserData::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserData::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 lastLogin = 7;
inline bool UserData::has_lastlogin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserData::set_has_lastlogin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserData::clear_has_lastlogin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserData::clear_lastlogin() {
  lastlogin_ = GOOGLE_ULONGLONG(0);
  clear_has_lastlogin();
}
inline ::google::protobuf::uint64 UserData::lastlogin() const {
  return lastlogin_;
}
inline void UserData::set_lastlogin(::google::protobuf::uint64 value) {
  set_has_lastlogin();
  lastlogin_ = value;
}

// optional uint64 firstLogin = 8;
inline bool UserData::has_firstlogin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserData::set_has_firstlogin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserData::clear_has_firstlogin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserData::clear_firstlogin() {
  firstlogin_ = GOOGLE_ULONGLONG(0);
  clear_has_firstlogin();
}
inline ::google::protobuf::uint64 UserData::firstlogin() const {
  return firstlogin_;
}
inline void UserData::set_firstlogin(::google::protobuf::uint64 value) {
  set_has_firstlogin();
  firstlogin_ = value;
}

// optional .user.UserActivityStatistics stats = 10;
inline bool UserData::has_stats() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserData::set_has_stats() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserData::clear_has_stats() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserData::clear_stats() {
  if (stats_ != NULL) stats_->::user::UserActivityStatistics::Clear();
  clear_has_stats();
}
inline const ::user::UserActivityStatistics& UserData::stats() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stats_ != NULL ? *stats_ : *default_instance().stats_;
#else
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
#endif
}
inline ::user::UserActivityStatistics* UserData::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::user::UserActivityStatistics;
  return stats_;
}
inline ::user::UserActivityStatistics* UserData::release_stats() {
  clear_has_stats();
  ::user::UserActivityStatistics* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void UserData::set_allocated_stats(::user::UserActivityStatistics* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// -------------------------------------------------------------------

// UserActivityStatistics

// required uint32 magazineCount = 1;
inline bool UserActivityStatistics::has_magazinecount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActivityStatistics::set_has_magazinecount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActivityStatistics::clear_has_magazinecount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActivityStatistics::clear_magazinecount() {
  magazinecount_ = 0u;
  clear_has_magazinecount();
}
inline ::google::protobuf::uint32 UserActivityStatistics::magazinecount() const {
  return magazinecount_;
}
inline void UserActivityStatistics::set_magazinecount(::google::protobuf::uint32 value) {
  set_has_magazinecount();
  magazinecount_ = value;
}

// required uint32 totalNumOfElements = 2;
inline bool UserActivityStatistics::has_totalnumofelements() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofelements() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserActivityStatistics::clear_has_totalnumofelements() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserActivityStatistics::clear_totalnumofelements() {
  totalnumofelements_ = 0u;
  clear_has_totalnumofelements();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofelements() const {
  return totalnumofelements_;
}
inline void UserActivityStatistics::set_totalnumofelements(::google::protobuf::uint32 value) {
  set_has_totalnumofelements();
  totalnumofelements_ = value;
}

// required uint32 totalNumOfGroupedElements = 3;
inline bool UserActivityStatistics::has_totalnumofgroupedelements() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofgroupedelements() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserActivityStatistics::clear_has_totalnumofgroupedelements() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserActivityStatistics::clear_totalnumofgroupedelements() {
  totalnumofgroupedelements_ = 0u;
  clear_has_totalnumofgroupedelements();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofgroupedelements() const {
  return totalnumofgroupedelements_;
}
inline void UserActivityStatistics::set_totalnumofgroupedelements(::google::protobuf::uint32 value) {
  set_has_totalnumofgroupedelements();
  totalnumofgroupedelements_ = value;
}

// required uint32 totalNumOfExecutedQueries = 4;
inline bool UserActivityStatistics::has_totalnumofexecutedqueries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofexecutedqueries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserActivityStatistics::clear_has_totalnumofexecutedqueries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserActivityStatistics::clear_totalnumofexecutedqueries() {
  totalnumofexecutedqueries_ = 0u;
  clear_has_totalnumofexecutedqueries();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofexecutedqueries() const {
  return totalnumofexecutedqueries_;
}
inline void UserActivityStatistics::set_totalnumofexecutedqueries(::google::protobuf::uint32 value) {
  set_has_totalnumofexecutedqueries();
  totalnumofexecutedqueries_ = value;
}

// required uint32 totalNumOfRequests = 5;
inline bool UserActivityStatistics::has_totalnumofrequests() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserActivityStatistics::set_has_totalnumofrequests() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserActivityStatistics::clear_has_totalnumofrequests() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserActivityStatistics::clear_totalnumofrequests() {
  totalnumofrequests_ = 0u;
  clear_has_totalnumofrequests();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalnumofrequests() const {
  return totalnumofrequests_;
}
inline void UserActivityStatistics::set_totalnumofrequests(::google::protobuf::uint32 value) {
  set_has_totalnumofrequests();
  totalnumofrequests_ = value;
}

// required uint32 totalModifiedItems = 6;
inline bool UserActivityStatistics::has_totalmodifieditems() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserActivityStatistics::set_has_totalmodifieditems() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserActivityStatistics::clear_has_totalmodifieditems() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserActivityStatistics::clear_totalmodifieditems() {
  totalmodifieditems_ = 0u;
  clear_has_totalmodifieditems();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totalmodifieditems() const {
  return totalmodifieditems_;
}
inline void UserActivityStatistics::set_totalmodifieditems(::google::protobuf::uint32 value) {
  set_has_totalmodifieditems();
  totalmodifieditems_ = value;
}

// required uint32 totalAddItems = 7;
inline bool UserActivityStatistics::has_totaladditems() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserActivityStatistics::set_has_totaladditems() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserActivityStatistics::clear_has_totaladditems() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserActivityStatistics::clear_totaladditems() {
  totaladditems_ = 0u;
  clear_has_totaladditems();
}
inline ::google::protobuf::uint32 UserActivityStatistics::totaladditems() const {
  return totaladditems_;
}
inline void UserActivityStatistics::set_totaladditems(::google::protobuf::uint32 value) {
  set_has_totaladditems();
  totaladditems_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
